## 整数的存储规则

整数在内存中都是以补码的形式进行存储，整数有正负之分。当需存储有符号数时，用第一位来表示正（0）和负（1）。

正数的反码和补码还是它本身，负数的反码是其原码除去最高符号位后其余位按位取反，补码是其反码在加上1 。

-128的补码是1000 0000，只有原码和补码，没有反码。

原码  -127~127  

反码  -127~127

补码  -128~127

## 浮点数存储规则

根据国际标准IEEE（电气和电子工程协会）规定，任何一个浮点数的二进制数可以写为：
Number = (-1) ^ S * M * 2 ^ E;//(S表示符号，E表示阶乘，M表示有效数字)

1. 当S为0时，表示一个正数；当S为1时，表示一个负数
2. M表示有效数字，1<= M <2
3. 2^E表示指数

而规定float类型有一个符号位（S），有8个指数位（E），和23个有效数字位（M）
double类型有一个符号位（S），有11个指数位（E），和52个有效数字位（M）
以float类型为例：

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwNDA0MTcwNDI2Mjk3?x-oss-process=image/format,png)

1. IEEE对于（有效数字）M和（指数）E有特殊的规定： （以float为例）
   因为M的值一定是1<= M <2，所以它绝对可以写成1.xxxxxxx的形式，所以规定M在存储时舍去第一个1，只存储小数点之后的数字。这样做节省了空间，以float类型为例，就可以保存23位小数信息，加上舍去的1就可以用23位来表示24个有效的信息。
2. 对于E（指数）E是一个无符号整数所以E的取值范围为（0~ 255），但是在计数中指数是可以为负的，所以规定在存入E时，在它原本的值上加上中间数（127），在使用时减去中间数（127），这样E的真正取值范围就成了（-127~128）。
   对于E还分为三种情况：

- E不全为0，不全为1:
  这时就用正常的计算规则，E的真实值就是E的字面值减去127（中间值)，M的值要加上最前面的省去的1。
- E全为0
  这时指数E等于1-127为真实值，M不在加上舍去的1，而是还原为0.xxxxxxxx小数。这样为了表示0，和一些很小的整数。
  所以在进行浮点数与0的比较时，要注意。
- E全为1
  当M全为0时，表示±无穷大（取决于符号位）；当M不全为1时，表示这数不是一个数（NaN）