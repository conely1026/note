在C#中的数据类型分为值类型和引用类型，对他们使用了不同但又相似的内存管理机制。

#### 1.值数据类型的内存管理

在进程的虚拟内存中，有一个区域称为栈。C#的值类型数据、传递给方法的参数副本都存储在这个栈中。在栈中存储数据时，是从高内存地址向低内存地址填充的。
操作系统维护一个变量，称为栈指针。栈指针为当前变量所占内存的最后一个字节地址，栈指针会根据需要随时调整，它总是会调整为指向栈中下一个空闲存储单元的地址。当有新的内存需求时，就根据当前栈指针的值开始往下来为该需求分配足够的内存单元，分配完后，栈指针更新为当前变量所占内存的最后一个字节地址，它将在下一次分配内存时调整为指向下一个空闲单元。
如：`int a= 10;`
声明一个整型的变量需要32位，也就是4个字节内存，假设当前栈指针为89999，则系统就会为变量a分配4个内存单元，分别为89996~89999，之后，栈指针更新为89995
`double d = 20.13;` //需要64位，也就是8个字节内存，存储在89988~89995

栈的工作方式是先进后出(FIFO)：在释放变量时，总是先释放后面声明的变量(后面分配内存)。

值类型和指针总是分配在被定义的地方，他们**不一定被分配到栈上**，如果一个值类型被声明在一个方法体外并且在一个引用类型中，那它就会在堆上进行分配。

#### 2.引用数据类型的内存管理

引用类型对象的引用存储在栈中(占4个字节的空间)，而它的实际数据存储在主托管堆或大对象堆上，托管堆是可用的4GB虚拟内存中的另一个内存区域。
大对象堆：在.NET下，因为压缩较大对象(大于85000个字节)很影响性能，所以为它们分配了自己的托管堆。.NET垃圾回收器不对大对象堆执行压缩过程。
如：`Person arabel= new Person();`
声明变量arabel时，在栈上为该变量分配4个字节的空间以存储一个引用，new运算符为对象Person对象在堆上分配空间，然后把该空间的地址赋给变量arabel，而构造函数则用来初始化。

.NET运行库为了给对象arabel分配空间，需要搜索堆，选取第一个未使用的且足够容纳对象所有数据的连续块。但垃圾回收器程序在回收堆中所有无引用的对象后，会执行压缩操作，即：把剩下的有用对象移动到堆的端部，挨在一起形成一个连续的内存块，并更新所有对象的引用为新地址，同时更新堆指针，方便为下一个新对象分配堆空间。

一般情况下，垃圾回收器在.NET运行库认为需要它时运行。
`System.GC`类是一个表示垃圾回收器的.NET类，可以调用`System.GC.Collect()`方法，强迫垃圾回收器在代码的某个地方运行。
当代码中有大量的对象刚刚取消引用，就比较适合调用垃圾回收器，但不能保证所有未引用的对象都能从堆中删除。
垃圾回收器运行时，它实际上会降低程序的性能，因为在它执行期间，将会暂停应用程序的其它所有线程。

#### 4.释放非托管的资源

有了垃圾回收器，意味着我们只要让不再需要的对象的所有引用都超出作用域，并允许垃圾回收器在需要时释放内存即可。
原则：在.net中，没有必要调用Dispose的时候，你就不要调用它（垃圾回收器运行时会占用/阻塞主线程）。
但是，垃圾回收器不知道如何释放非托管的资源（如文件句柄、网络连接、数据库连接）。
在定义一个类时，有两种机制来自动释放非托管的资源：（更保险的做法是同时使用两种机制，防止忘记调用`Dispose()`方法）

1. 声明一个析构函数（终结器）；
2. 为类实现`System.IDiposable`接口，实现`Dispose()`方法；

#### 5.析构函数：

C#编译器在编译析构函数时，它会隐式地把析构函数编译为等价于`Finalize()`方法，从而确保执行父类的`Finalize()`方法。
定义方式如下：析构函数无返回值、无参数、无访问修饰符

由于C#使用垃圾回收器的工作方式，无法确定C#对象的析构函数何时执行。
定义了析构函数的对象需要经过两次垃圾回收处理才能被销毁（第二次调用析构函数时才真正删除对象），而没有定义析构函数的对象反而只需要一次处理即可删除。
如果频繁使用析构函数，而且执行长时间的清理任务，会严重影响性能。

#### 6.IDiposable接口：

所以，推荐通过为类实现`System.IDisposable`接口，实现`Dispose()`方法，来替代析构函数。`IDisposable`接口定义的模式为释放非托管资源提供了确定的机制，并避免了对垃圾回收器依赖的问题。
`IDisposable`接口声明了`Dispose()`方法，无参数，无返回值。可以为Dispose()方法实现代码来显式地释放由对象直接使用的所有非托管资源，并在所有也实现`IDisposable`接口的封装对象中调用`Dispose()`方法。这样，该方法可以可以精确地控制非托管资源的释放。

注意：如果在`Dispose()`方法调用之前的运行代码抛出了异常，则该方法就执行不到了，所以应该使用`try...finally`，并把`Dispose()`方法放在`finally`块内，以确保它的执行。如下：

```javascript
Person person = null;  //假设Person类实现了IDisposable接口
try
{
    person = new Person();
}
finally { if(person != null) { person.Dispose(); } }
```

C#提供了`using`关键字语法，可以确保在实现了`IDisposable`接口的对象的引用超出作用域时，在该对象上自动调用`Dispose()`方法，如下：

```c#
using ( Person person = new Person() )
{ ..... }
```

using语句后面是一对"()"，其中是引用变量的声明和实例化，该语句是其中的变量放在随后的语句块中，并且在变量超出作用域时，即使抛出异常，也会自动调用`Dispose()`方法。
然后，在需要捕获其它异常时，使用`try...finally`的方式就会比较清晰。而常常为`Dispose()`方法定义一个包装方法`Close()`，这样显得更清晰明了(Close()方法内仅调用`Dispose()`方法)

为了防止忘记调用`Dispose()`方法，更保险的做法是同时实现两种机制：即实现`IDisposable`接口的`Dispose()`方法，也定义析构函数。

- 托管资源：由CLR管理分配和释放的资源，即由CLR里new出来的对象；
- 非托管资源：不受CLR管理的对象，windows内核对象，如文件、数据库连接、套接字、COM对象等；
  　　毫无例外地，如果我们的类型使用到了非托管资源，或者需要显式释放的托管资源，那么，就需要让类型继承接口`IDisposable`。这相当于是告诉调用者，该类型是需要显式释放资源的，你需要调用我的`Dispose`方法。

#### 8.及时让不再需要的静态字段的引用等于null：

在CLR托管应用程序中，存在一个根的概念，类型的静态字段、方法参数以及局部变量都可以作为根存在（值类型不能作为根，只有引用类型的指针才能作为根）。垃圾回收器会沿着线程栈上行检查根，如果发现该根的引用为空，则标记该根为可被释放。
而JIT编译器是一个经过优化的编译器，无论我们是否为变量赋值为null，该语句都会被忽略掉，在我们将项目设置为Release模式下，该语句将根本不会被编译进运行时内。
但是，在另外一种情况下，却要注意及时为变量赋值为null。那就是类型的静态字段。而且，为类型对象赋值为null，并不意味着同时为该类型的静态字段赋值为null：当执行垃圾回收时，当类型的对象被回收的时候，该类型的静态字段并没有被回收(因为静态字段是属于类的，它日后可能会被该类型的其它实例继续使用)。
实际工作中，一旦我们感觉到自己的静态引用类型参数占用内存空间比较大，并且使用完毕后不再使用，则可以立刻将其赋值为null。这也许并不必要，但这绝对是一个好习惯。